<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Terminal AI Control</title>
  
  <!-- xterm.js - stable version -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css">
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.min.js"></script>
  
  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>

  <!-- Styles -->
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading">
    <div class="spinner"></div>
    <div class="loading-text">ÌÑ∞ÎØ∏ÎÑê Ïó∞Í≤∞ Ï§ë...</div>
  </div>

  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <button id="toggle-explorer-btn" class="explorer-toggle-btn" title="Toggle File Explorer">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm1 2v14h14V5H5zm2 2h4v4H7V7zm0 6h4v4H7v-4zm6-6h4v4h-4V7zm0 6h4v4h-4v-4z"/></svg>
      </button>
      <div class="logo">
        <span class="logo-icon">üñ•Ô∏è</span>
        <span>Terminal AI Control</span>
      </div>
      <div class="status-badge">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-text">Ïó∞Í≤∞ Ï§ë...</span>
        <button class="btn-reconnect" id="reconnect-btn" onclick="reconnect()" title="Ïû¨Ïó∞Í≤∞" style="display: none;">
          üîÑ
        </button>
      </div>
    </div>
  </header>

  <div class="main-container">
    <!-- File Explorer Panel -->
    <aside id="file-explorer" class="file-explorer-panel">
      <div class="file-explorer-header">
        <span>Project</span>
        <button id="refresh-explorer-btn" title="Refresh">üîÑ</button>
      </div>
      <div id="file-explorer-content" class="file-explorer-content">
        <!-- Tree will be rendered here -->
        <div class="spinner-container"><div class="spinner"></div></div>
      </div>
    </aside>

    <!-- Resizer -->
    <div id="resizer" class="resizer"></div>

    <!-- Terminal -->
    <div class="terminal-wrapper">
      <div class="terminal-header">
        <div class="terminal-tabs" id="terminal-tabs">
          <!-- Tabs will be dynamically added here -->
        </div>
        <div class="terminal-controls">
          <div class="terminal-control control-close" onclick="window.close()"></div>
          <div class="terminal-control control-minimize"></div>
          <div class="terminal-control control-maximize" onclick="toggleFullscreen()"></div>
        </div>
      </div>
      <div id="terminal-container"></div>
    </div>
  </div>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-left">
      <div class="shortcut">
        <span class="key">Ctrl</span>+<span class="key">L</span> ÏßÄÏö∞Í∏∞
      </div>
      <div class="shortcut">
        <span class="key">Ctrl</span>+<span class="key">C</span> Ï§ëÎã®
      </div>
    </div>
    <div class="footer-right">
      Your server. Your network. Your AI.
    </div>
  </footer>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    // --- Global State ---
    let socket;
    let terminals = new Map();
    let activeTerminalId = null;
    let tabCounter = 0;
    let sessionId = getCookie('sessionId') || null;
    let workingDirectory = null;

    // --- Cookie Helpers ---
    function setCookie(name, value, days = 365) {
      const expires = new Date(Date.now() + days * 864e5).toUTCString();
      document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/';
    }

    function getCookie(name) {
      return document.cookie.split('; ').reduce((r, v) => {
        const parts = v.split('=');
        return parts[0] === name ? decodeURIComponent(parts[1]) : r;
      }, '');
    }

    // --- File Explorer Logic ---
    function requestFileTree(newPath) {
      if (newPath) {
        workingDirectory = newPath;
      }
      const content = document.getElementById('file-explorer-content');
      if (socket?.connected && workingDirectory) {
        content.innerHTML = '<div class="spinner-container"><div class="spinner"></div></div>';
        socket.emit('filetree:get', { targetPath: workingDirectory });
      }
    }

    function renderFileTree(node, container) {
      const ul = document.createElement('ul');
      if (node.path !== workingDirectory) {
        ul.classList.add('hidden');
      }

      const children = Array.isArray(node.children) ? node.children : [];

      for (const item of children) {
        const li = document.createElement('li');
        li.dataset.path = item.path;
        const entry = document.createElement('div');
        entry.className = `file-entry type-${item.type}`;
        const icon = document.createElement('span');
        icon.className = 'icon';
        const name = document.createElement('span');
        name.className = 'name';
        name.textContent = item.name;
        
        entry.appendChild(icon);
        entry.appendChild(name);
        li.appendChild(entry);

        if (item.type === 'directory') {
          if (item.error === 'permission_denied') {
            entry.classList.add('unreadable');
            icon.textContent = 'üîí';
            entry.title = 'Permission denied';
          } else {
            icon.textContent = 'üìÅ';
            entry.onclick = (e) => {
              e.stopPropagation();
              entry.classList.toggle('open');
              const childUl = li.querySelector('ul');
              if (childUl) {
                childUl.classList.toggle('hidden');
              }
            };
            renderFileTree(item, li);
          }
        } else {
          icon.textContent = 'üìÑ';
          entry.onclick = (e) => {
            e.stopPropagation();
            const term = terminals.get(activeTerminalId);
            if (term) {
              term.terminal.paste(`'${item.path}'`);
            }
          };
        }
        ul.appendChild(li);
      }
      container.appendChild(ul);
    }
    
    function initializeFileExplorer() {
        const explorer = document.getElementById('file-explorer');
        const resizer = document.getElementById('resizer');
        const toggleBtn = document.getElementById('toggle-explorer-btn');
        const refreshBtn = document.getElementById('refresh-explorer-btn');

        toggleBtn.onclick = () => {
          explorer.classList.toggle('collapsed');
          resizer.classList.toggle('collapsed');
        };

        refreshBtn.onclick = requestFileTree;

        if (window.innerWidth <= 768) {
            explorer.classList.add('collapsed');
            resizer.classList.add('collapsed');
        }

        let isResizing = false;
        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.removeEventListener('mousemove', handleMouseMove);
            });
        });

        function handleMouseMove(e) {
            if (!isResizing) return;
            const sidebarWidth = e.clientX;
            if (sidebarWidth > 200 && sidebarWidth < 600) {
                explorer.style.width = sidebarWidth + 'px';
            }
        }
    }


    // --- Terminal & Session Logic ---
        function createTerminalInstance() {
          const terminal = new Terminal({
            cursorBlink: true,
            cursorStyle: 'bar',
            fontSize: 15,
            lineHeight: 1.4,
            fontFamily: '"JetBrains Mono", "Fira Code", "SF Mono", Menlo, Monaco, "Courier New", monospace',
            theme: {
              background: '#252936',
              foreground: '#f0f2f5',
              cursor: '#6c8eef',
              cursorAccent: '#252936',
              selection: 'rgba(108, 142, 239, 0.4)',
              black: '#3d4153',
              red: '#f87171',
              green: '#4ade80',
              yellow: '#fbbf24',
              blue: '#6c8eef',
              magenta: '#c084fc',
              cyan: '#22d3ee',
              white: '#cbd5e1',
              brightBlack: '#64748b',
              brightRed: '#fca5a5',
              brightGreen: '#86efac',
              brightYellow: '#fcd34d',
              brightBlue: '#93b4ff',
              brightMagenta: '#d8b4fe',
              brightCyan: '#67e8f9',
              brightWhite: '#f1f5f9'
            },
            allowTransparency: false,
            scrollback: 10000,
            tabStopWidth: 4
          });
    
          const fitAddon = new FitAddon.FitAddon();
          const webLinksAddon = new WebLinksAddon.WebLinksAddon();
          terminal.loadAddon(fitAddon);
          terminal.loadAddon(webLinksAddon);
    
          // Register OSC handler for CWD detection
          terminal.parser.registerOscHandler(777, (data) => {
            const payload = data.substring(data.indexOf(';') + 1);
            if (payload.startsWith('CWD=')) {
              const newPath = payload.substring(4).trim();
              if (newPath && newPath !== workingDirectory) {
                console.log("CWD changed to:", newPath);
                requestFileTree(newPath);
              }
            }
            return true;
          });
    
          return { terminal, fitAddon };
        }

    function addTerminalTab() {
      if (!socket?.connected) {
        showToast('ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§', 'error');
        return;
      }
      socket.emit('terminal:create', { cols: 80, rows: 24 });
    }

    function switchTerminal(terminalId) {
      if (activeTerminalId === terminalId) return;
      if (activeTerminalId) {
        const current = terminals.get(activeTerminalId);
        if (current?.terminal) current.terminal.element.style.display = 'none';
      }
      const selected = terminals.get(terminalId);
      if (selected?.terminal) {
        selected.terminal.element.style.display = 'block';
        selected.terminal.focus();
        selected.fitAddon.fit();
        activeTerminalId = terminalId;
        updateTabUI();
      }
    }

    function closeTerminalTab(terminalId, event) {
      if (event) event.stopPropagation();
      const termData = terminals.get(terminalId);
      if (!termData) return;
      if (terminals.size === 1) {
        showToast('ÎßàÏßÄÎßâ ÌÑ∞ÎØ∏ÎÑêÏùÄ Îã´ÏùÑ Ïàò ÏóÜÏäµÎãàÎã§', 'error');
        return;
      }
      socket.emit('terminal:close', { terminalId });
      if (termData.terminal?.element) termData.terminal.dispose();
      terminals.delete(terminalId);
      const tabElement = document.querySelector(`[data-terminal-id="${terminalId}"]`);
      if (tabElement) tabElement.remove();
      if (activeTerminalId === terminalId) {
        const firstTerminalId = terminals.keys().next().value;
        if (firstTerminalId) switchTerminal(firstTerminalId);
      }
    }

    function updateTabUI() {
      document.querySelectorAll('.terminal-tab').forEach(tab => {
        const terminalId = tab.getAttribute('data-terminal-id');
        tab.classList.toggle('active', terminalId === activeTerminalId);
      });
    }

    function renderTabs() {
      const tabsContainer = document.getElementById('terminal-tabs');
      tabsContainer.innerHTML = '';
      terminals.forEach((termData, terminalId) => {
        const tab = document.createElement('div');
        tab.className = 'terminal-tab';
        tab.setAttribute('data-terminal-id', terminalId);
        const label = document.createElement('span');
        label.className = 'tab-label';
        label.textContent = termData.customName || `ÌÑ∞ÎØ∏ÎÑê ${termData.tabNumber}`;
        tab.ondblclick = () => {
          tab.onclick = null;
          label.contentEditable = true;
          label.focus();
          document.execCommand('selectAll', false, null);
          const saveName = () => {
            label.contentEditable = false;
            tab.onclick = () => switchTerminal(terminalId);
            const newName = label.textContent.trim();
            if (newName && newName !== (termData.customName || `ÌÑ∞ÎØ∏ÎÑê ${termData.tabNumber}`)) {
              termData.customName = newName;
              socket.emit('terminal:rename', { terminalId, customName: newName });
              showToast(`ÌÑ∞ÎØ∏ÎÑê Ïù¥Î¶ÑÏù¥ "${newName}"(Ïúº)Î°ú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.`, 'success');
            } else {
              label.textContent = termData.customName || `ÌÑ∞ÎØ∏ÎÑê ${termData.tabNumber}`;
            }
          };
          label.onblur = saveName;
          label.onkeydown = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              saveName();
            } else if (e.key === 'Escape') {
              label.contentEditable = false;
              label.textContent = termData.customName || `ÌÑ∞ÎØ∏ÎÑê ${termData.tabNumber}`;
              tab.onclick = () => switchTerminal(terminalId);
              label.blur();
            }
          };
        };
        tab.onclick = () => switchTerminal(terminalId);
        tab.appendChild(label);
        const closeBtn = document.createElement('span');
        closeBtn.className = 'tab-close';
        closeBtn.innerHTML = '√ó';
        closeBtn.onclick = (e) => closeTerminalTab(terminalId, e);
        tab.appendChild(closeBtn);
        tabsContainer.appendChild(tab);
      });
      const newTabBtn = document.createElement('div');
      newTabBtn.className = 'new-tab-btn';
      newTabBtn.innerHTML = '+';
      newTabBtn.onclick = addTerminalTab;
      tabsContainer.appendChild(newTabBtn);
      updateTabUI();
    }

    function connect() {
      socket = io({ reconnection: true, reconnectionAttempts: 10, reconnectionDelay: 1000 });

      socket.on('connect', () => {
        console.log('Connected to server');
        updateStatus(true);
        socket.emit('page:visibility', { hidden: document.hidden });
        console.log('Requesting session init with ID:', sessionId || 'none');
        socket.emit('session:init', { sessionId });
      });

      socket.on('session:created', ({ sessionId: newSessionId, workingDirectory: wd }) => {
        console.log('New session created:', newSessionId);
        sessionId = newSessionId;
        setCookie('sessionId', sessionId);
        workingDirectory = wd;
        requestFileTree();
        addTerminalTab();
      });

      socket.on('session:restored', ({ sessionId: restoredSessionId, terminals: terminalList, workingDirectory: wd }) => {
        console.log('Session restored:', restoredSessionId);
        sessionId = restoredSessionId;
        workingDirectory = wd;
        requestFileTree();
        terminals.forEach(term => { if (term.terminal) term.terminal.dispose(); });
        terminals.clear();
        tabCounter = 0;
        terminalList.forEach(termInfo => {
          const { terminalId, pid, tabNumber } = termInfo;
          const { terminal, fitAddon } = createTerminalInstance();
          terminal.open(document.getElementById('terminal-container'));
          terminal.element.style.display = 'none';
          fitAddon.fit();
          terminal.onData((inputData) => {
            if (socket?.connected) socket.emit('terminal:input', { terminalId, data: inputData });
          });
          terminals.set(terminalId, { terminal, fitAddon, tabNumber: tabNumber, customName: termInfo.customName });
          if (tabNumber > tabCounter) tabCounter = tabNumber;
        });
        renderTabs();
        if (terminalList.length > 0) switchTerminal(terminalList[0].terminalId);
        document.getElementById('loading').classList.add('hidden');
        showToast(`ÏÑ∏ÏÖò Î≥µÍµ¨Îê®: ${terminalList.length}Í∞ú ÌÑ∞ÎØ∏ÎÑê`, 'success');
      });

      socket.on('terminal:buffered', ({ terminalId, data }) => {
        const termData = terminals.get(terminalId);
        if (termData?.terminal) termData.terminal.write(data);
      });

      socket.on('session:replaced', ({ message }) => {
        showToast(message, 'error');
        setTimeout(() => { window.location.reload(); }, 2000);
      });

      socket.on('terminal:ready', (data) => {
        console.log('Terminal ready:', data);
        const { terminalId, pid, tabNumber, customName } = data;
        const { terminal, fitAddon } = createTerminalInstance();
        terminal.open(document.getElementById('terminal-container'));
        fitAddon.fit();
        terminal.onData((inputData) => {
          if (socket?.connected) socket.emit('terminal:input', { terminalId, data: inputData });
        });
        terminals.set(terminalId, { terminal, fitAddon, tabNumber: tabNumber, customName: customName });
        if (tabNumber > tabCounter) tabCounter = tabNumber;
        if (terminals.size === 1) document.getElementById('loading').classList.add('hidden');
        renderTabs();
        switchTerminal(terminalId);
        showToast(`ÌÑ∞ÎØ∏ÎÑê ${tabNumber} Ïó∞Í≤∞Îê®`, 'success');
      });

      socket.on('terminal:data', ({ terminalId, data }) => {
        const termData = terminals.get(terminalId);
        if (termData?.terminal) termData.terminal.write(data);
      });

      socket.on('terminal:exit', ({ terminalId, exitCode }) => {
        const termData = terminals.get(terminalId);
        if (termData?.terminal) termData.terminal.writeln(`\r\n\x1b[33m[ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£å: ${exitCode}]\x1b[0m`);
        showToast(`ÌÑ∞ÎØ∏ÎÑê ${termData?.tabNumber} ÏÑ∏ÏÖò Ï¢ÖÎ£åÎê®`, 'info');
      });

      socket.on('terminal:error', (error) => { showToast(error, 'error'); });
      socket.on('disconnect', () => { updateStatus(false); showToast('Ïó∞Í≤∞ ÎÅäÍπÄ', 'error'); });
      socket.on('connect_error', (error) => { console.error('Connection error:', error); updateStatus(false); });
      
      socket.on('filetree:data', ({ path, tree }) => {
        const content = document.getElementById('file-explorer-content');
        content.innerHTML = '';
        renderFileTree({ path, children: tree, type: 'directory' }, content);
      });

      socket.on('filetree:error', (error) => {
        const content = document.getElementById('file-explorer-content');
        content.innerHTML = `<div class="error-message">${error}</div>`;
        showToast(error, 'error');
      });

      window.addEventListener('resize', () => {
        if (activeTerminalId) {
          const termData = terminals.get(activeTerminalId);
          if (termData && socket?.connected) {
            termData.fitAddon.fit();
            socket.emit('terminal:resize', { terminalId: activeTerminalId, cols: termData.terminal.cols, rows: termData.terminal.rows });
          }
        }
      });
    }

    function updateStatus(connected) {
      const dot = document.getElementById('status-dot');
      const text = document.getElementById('status-text');
      const reconnectBtn = document.getElementById('reconnect-btn');
      if (connected) {
        dot.classList.add('connected');
        text.textContent = 'Ïó∞Í≤∞Îê®';
        reconnectBtn.style.display = 'none';
      } else {
        dot.classList.remove('connected');
        text.textContent = 'Ïó∞Í≤∞ ÎÅäÍπÄ';
        reconnectBtn.style.display = 'flex';
      }
    }

    function reconnect() {
      document.getElementById('loading').classList.remove('hidden');
      terminals.forEach((termData) => { if (termData.terminal) termData.terminal.dispose(); });
      terminals.clear();
      activeTerminalId = null;
      tabCounter = 0;
      if (socket) socket.disconnect();
      connect();
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    function showToast(message, type = 'info') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      const icons = { success: '‚úÖ', error: '‚ùå', info: '‚ÑπÔ∏è' };
      toast.innerHTML = `${icons[type] || '‚ÑπÔ∏è'} ${message}`;
      container.appendChild(toast);
      setTimeout(() => {
        toast.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    document.addEventListener('DOMContentLoaded', () => {
      connect();
      initializeFileExplorer();
    });

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && socket && !socket.connected) {
        reconnect();
      }
    });
  </script>
</body>
</html>
