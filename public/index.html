<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Terminal AI Control</title>
  
  <!-- xterm.js - stable version -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css">
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.min.js"></script>
  
  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>

  <!-- Styles -->
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading">
    <div class="spinner"></div>
    <div class="loading-text">í„°ë¯¸ë„ ì—°ê²° ì¤‘...</div>
  </div>

  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">
        <span class="logo-icon">ğŸ–¥ï¸</span>
        <span>Terminal AI Control</span>
      </div>
      <div class="status-badge">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-text">ì—°ê²° ì¤‘...</span>
        <button class="btn-reconnect" id="reconnect-btn" onclick="reconnect()" title="ì¬ì—°ê²°" style="display: none;">
          ğŸ”„
        </button>
      </div>
    </div>
  </header>

  <!-- Terminal -->
  <div class="terminal-wrapper">
    <div class="terminal-header">
      <div class="terminal-tabs" id="terminal-tabs">
        <!-- Tabs will be dynamically added here -->
      </div>
      <div class="terminal-controls">
        <div class="terminal-control control-close" onclick="window.close()"></div>
        <div class="terminal-control control-minimize"></div>
        <div class="terminal-control control-maximize" onclick="toggleFullscreen()"></div>
      </div>
    </div>
    <div id="terminal-container"></div>
  </div>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-left">
      <div class="shortcut">
        <span class="key">Ctrl</span>+<span class="key">L</span> ì§€ìš°ê¸°
      </div>
      <div class="shortcut">
        <span class="key">Ctrl</span>+<span class="key">C</span> ì¤‘ë‹¨
      </div>
    </div>
    <div class="footer-right">
      Your server. Your network. Your AI.
    </div>
  </footer>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    let socket;
    let terminals = new Map(); // Map of terminalId -> { terminal, fitAddon }
    let activeTerminalId = null;
    let tabCounter = 0;
    let sessionId = getCookie('sessionId') || null; // Session ID for persistence

    // Cookie helper functions
    function setCookie(name, value, days = 365) {
      const expires = new Date(Date.now() + days * 864e5).toUTCString();
      document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/';
    }

    function getCookie(name) {
      return document.cookie.split('; ').reduce((r, v) => {
        const parts = v.split('=');
        return parts[0] === name ? decodeURIComponent(parts[1]) : r;
      }, '');
    }

    // Create a new terminal instance
    function createTerminalInstance() {
      const terminal = new Terminal({
        cursorBlink: true,
        cursorStyle: 'bar',
        fontSize: 15,
        lineHeight: 1.4,
        fontFamily: '"JetBrains Mono", "Fira Code", "SF Mono", Menlo, Monaco, "Courier New", monospace',
        theme: {
          background: '#252936',
          foreground: '#f0f2f5',
          cursor: '#6c8eef',
          cursorAccent: '#252936',
          selection: 'rgba(108, 142, 239, 0.4)',
          black: '#3d4153',
          red: '#f87171',
          green: '#4ade80',
          yellow: '#fbbf24',
          blue: '#6c8eef',
          magenta: '#c084fc',
          cyan: '#22d3ee',
          white: '#cbd5e1',
          brightBlack: '#64748b',
          brightRed: '#fca5a5',
          brightGreen: '#86efac',
          brightYellow: '#fcd34d',
          brightBlue: '#93b4ff',
          brightMagenta: '#d8b4fe',
          brightCyan: '#67e8f9',
          brightWhite: '#f1f5f9'
        },
        allowTransparency: false,
        scrollback: 10000,
        tabStopWidth: 4
      });

      const fitAddon = new FitAddon.FitAddon();
      const webLinksAddon = new WebLinksAddon.WebLinksAddon();

      terminal.loadAddon(fitAddon);
      terminal.loadAddon(webLinksAddon);

      return { terminal, fitAddon };
    }

    // Add a new terminal tab
    function addTerminalTab() {
      if (!socket?.connected) {
        showToast('ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'error');
        return;
      }

      // Request server to create a new terminal
      socket.emit('terminal:create', {
        cols: 80,
        rows: 24
      });
    }

    // Switch to a specific terminal
    function switchTerminal(terminalId) {
      if (activeTerminalId === terminalId) return;

      // Hide current terminal
      if (activeTerminalId) {
        const current = terminals.get(activeTerminalId);
        if (current?.terminal) {
          current.terminal.element.style.display = 'none';
        }
      }

      // Show selected terminal
      const selected = terminals.get(terminalId);
      if (selected?.terminal) {
        selected.terminal.element.style.display = 'block';
        selected.terminal.focus();
        selected.fitAddon.fit();
        activeTerminalId = terminalId;

        // Update tab UI
        updateTabUI();
      }
    }

    // Close a terminal tab
    function closeTerminalTab(terminalId, event) {
      if (event) {
        event.stopPropagation();
      }

      const termData = terminals.get(terminalId);
      if (!termData) return;

      // Don't close if it's the last terminal
      if (terminals.size === 1) {
        showToast('ë§ˆì§€ë§‰ í„°ë¯¸ë„ì€ ë‹«ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
        return;
      }

      // Close on server
      socket.emit('terminal:close', { terminalId });

      // Remove from DOM
      if (termData.terminal?.element) {
        termData.terminal.dispose();
      }

      // Remove from map
      terminals.delete(terminalId);

      // Remove tab from UI
      const tabElement = document.querySelector(`[data-terminal-id="${terminalId}"]`);
      if (tabElement) {
        tabElement.remove();
      }

      // If this was the active terminal, switch to another
      if (activeTerminalId === terminalId) {
        const firstTerminalId = terminals.keys().next().value;
        if (firstTerminalId) {
          switchTerminal(firstTerminalId);
        }
      }
    }

    // Update tab UI to reflect active state
    function updateTabUI() {
      document.querySelectorAll('.terminal-tab').forEach(tab => {
        const terminalId = tab.getAttribute('data-terminal-id');
        if (terminalId === activeTerminalId) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });
    }

    // Render tabs
    function renderTabs() {
      const tabsContainer = document.getElementById('terminal-tabs');
      tabsContainer.innerHTML = '';

      terminals.forEach((termData, terminalId) => {
        const tab = document.createElement('div');
        tab.className = 'terminal-tab';
        tab.setAttribute('data-terminal-id', terminalId);
        
        const label = document.createElement('span');
        label.className = 'tab-label';
        label.textContent = termData.customName || `í„°ë¯¸ë„ ${termData.tabNumber}`;
        
        // Handle renaming on double-click
        tab.ondblclick = () => {
          // Temporarily disable the single-click handler to prevent switching
          tab.onclick = null; 
          label.contentEditable = true;
          label.focus();
          document.execCommand('selectAll', false, null);

          const saveName = () => {
            label.contentEditable = false;
            // Re-enable the single-click handler
            tab.onclick = () => switchTerminal(terminalId);

            const newName = label.textContent.trim();
            
            // Update only if the name has actually changed
            if (newName && newName !== (termData.customName || `í„°ë¯¸ë„ ${termData.tabNumber}`)) {
              termData.customName = newName;
              socket.emit('terminal:rename', { terminalId, customName: newName });
              showToast(`í„°ë¯¸ë„ ì´ë¦„ì´ "${newName}"(ìœ¼)ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
            } else {
              // If the name is empty or unchanged, restore the original text
              label.textContent = termData.customName || `í„°ë¯¸ë„ ${termData.tabNumber}`;
            }
          };

          // Save when focus is lost
          label.onblur = saveName;
          
          // Save on Enter, cancel on Escape
          label.onkeydown = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              saveName();
            } else if (e.key === 'Escape') {
              label.contentEditable = false;
              // Restore original name and exit edit mode
              label.textContent = termData.customName || `í„°ë¯¸ë„ ${termData.tabNumber}`;
              tab.onclick = () => switchTerminal(terminalId);
              label.blur(); // Trigger blur to clean up other listeners
            }
          };
        };

        // Set the initial single-click handler
        tab.onclick = () => switchTerminal(terminalId);

        tab.appendChild(label);

        const closeBtn = document.createElement('span');
        closeBtn.className = 'tab-close';
        closeBtn.innerHTML = 'Ã—';
        closeBtn.onclick = (e) => closeTerminalTab(terminalId, e);
        tab.appendChild(closeBtn);

        tabsContainer.appendChild(tab);
      });

      // Add new tab button
      const newTabBtn = document.createElement('div');
      newTabBtn.className = 'new-tab-btn';
      newTabBtn.innerHTML = '+';
      newTabBtn.onclick = addTerminalTab;
      tabsContainer.appendChild(newTabBtn);

      updateTabUI();
    }

    // Connect to server
    function connect() {
      socket = io({
        reconnection: true,
        reconnectionAttempts: 10,
        reconnectionDelay: 1000
      });

      socket.on('connect', () => {
        console.log('Connected to server');
        updateStatus(true);

        // Send initial visibility state
        socket.emit('page:visibility', { hidden: document.hidden });

        // Initialize or restore session
        console.log('Requesting session init with ID:', sessionId || 'none');
        socket.emit('session:init', { sessionId });
      });

      // Session created (new session)
      socket.on('session:created', ({ sessionId: newSessionId }) => {
        console.log('New session created:', newSessionId);
        sessionId = newSessionId;
        setCookie('sessionId', sessionId);

        // Create first terminal
        addTerminalTab();
      });

      // Session restored (reconnected to existing session)
      socket.on('session:restored', ({ sessionId: restoredSessionId, terminals: terminalList }) => {
        console.log('Session restored:', restoredSessionId, 'with terminals:', terminalList);
        sessionId = restoredSessionId;

        // Clear existing terminals
        terminals.forEach(term => {
          if (term.terminal) {
            term.terminal.dispose();
          }
        });
        terminals.clear();
        tabCounter = 0;

        // Recreate terminal instances for each restored terminal
        terminalList.forEach(termInfo => {
          const { terminalId, pid, tabNumber } = termInfo;

          // Create terminal instance
          const { terminal, fitAddon } = createTerminalInstance();

          // Open terminal in container (hidden initially)
          terminal.open(document.getElementById('terminal-container'));
          terminal.element.style.display = 'none';
          fitAddon.fit();

          // Handle terminal input
          terminal.onData((inputData) => {
            if (socket?.connected) {
              socket.emit('terminal:input', {
                terminalId,
                data: inputData
              });
            }
          });

          // Store terminal
          terminals.set(terminalId, {
            terminal,
            fitAddon,
            tabNumber: tabNumber,
            customName: termInfo.customName
          });

          // Update tab counter
          if (tabNumber > tabCounter) {
            tabCounter = tabNumber;
          }
        });

        // Render tabs
        renderTabs();

        // Switch to first terminal
        if (terminalList.length > 0) {
          switchTerminal(terminalList[0].terminalId);
        }

        // Hide loading
        document.getElementById('loading').classList.add('hidden');

        // Show restored message
        showToast(`ì„¸ì…˜ ë³µêµ¬ë¨: ${terminalList.length}ê°œ í„°ë¯¸ë„`, 'success');
      });

      // Receive buffered output
      socket.on('terminal:buffered', ({ terminalId, data }) => {
        console.log(`Received buffered output for ${terminalId}:`, data.length, 'bytes');
        const termData = terminals.get(terminalId);
        if (termData?.terminal) {
          termData.terminal.write(data);
        }
      });

      // Session replaced (logged in from another location)
      socket.on('session:replaced', ({ message }) => {
        showToast(message, 'error');
        setTimeout(() => {
          window.location.reload();
        }, 2000);
      });

      socket.on('terminal:ready', (data) => {
        console.log('Terminal ready:', data);
        const { terminalId, pid, tabNumber, customName } = data;

        // Create terminal instance
        const { terminal, fitAddon } = createTerminalInstance();

        // Open terminal in container
        terminal.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        // Handle terminal input
        terminal.onData((inputData) => {
          if (socket?.connected) {
            socket.emit('terminal:input', {
              terminalId,
              data: inputData
            });
          }
        });

        // Store terminal (use server's tabNumber)
        terminals.set(terminalId, {
          terminal,
          fitAddon,
          tabNumber: tabNumber,
          customName: customName
        });

        // Update local tab counter
        if (tabNumber > tabCounter) {
          tabCounter = tabNumber;
        }

        // Hide loading on first terminal
        if (terminals.size === 1) {
          document.getElementById('loading').classList.add('hidden');
        }

        // Render tabs and switch to new terminal
        renderTabs();
        switchTerminal(terminalId);

        showToast(`í„°ë¯¸ë„ ${tabNumber} ì—°ê²°ë¨`, 'success');
      });

      socket.on('terminal:data', ({ terminalId, data }) => {
        const termData = terminals.get(terminalId);
        if (termData?.terminal) {
          termData.terminal.write(data);
        }
      });

      socket.on('terminal:exit', ({ terminalId, exitCode }) => {
        const termData = terminals.get(terminalId);
        if (termData?.terminal) {
          termData.terminal.writeln(`\r\n\x1b[33m[í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ: ${exitCode}]\x1b[0m`);
        }
        showToast(`í„°ë¯¸ë„ ${termData?.tabNumber} ì„¸ì…˜ ì¢…ë£Œë¨`, 'info');
      });

      socket.on('terminal:error', (error) => {
        showToast(error, 'error');
      });

      socket.on('disconnect', () => {
        updateStatus(false);
        showToast('ì—°ê²° ëŠê¹€', 'error');
      });

      socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
        updateStatus(false);
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (activeTerminalId) {
          const termData = terminals.get(activeTerminalId);
          if (termData && socket?.connected) {
            termData.fitAddon.fit();
            socket.emit('terminal:resize', {
              terminalId: activeTerminalId,
              cols: termData.terminal.cols,
              rows: termData.terminal.rows
            });
          }
        }
      });
    }

    // Update connection status
    function updateStatus(connected) {
      const dot = document.getElementById('status-dot');
      const text = document.getElementById('status-text');
      const reconnectBtn = document.getElementById('reconnect-btn');

      if (connected) {
        dot.classList.add('connected');
        text.textContent = 'ì—°ê²°ë¨';
        reconnectBtn.style.display = 'none';
      } else {
        dot.classList.remove('connected');
        text.textContent = 'ì—°ê²° ëŠê¹€';
        reconnectBtn.style.display = 'flex';
      }
    }

    // Reconnect
    function reconnect() {
      document.getElementById('loading').classList.remove('hidden');

      // Clear all terminals
      terminals.forEach((termData) => {
        if (termData.terminal) {
          termData.terminal.dispose();
        }
      });
      terminals.clear();
      activeTerminalId = null;
      tabCounter = 0;

      if (socket) {
        socket.disconnect();
      }

      connect();
    }

    // Toggle fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    // Show toast notification
    function showToast(message, type = 'info') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const icons = {
        success: 'âœ…',
        error: 'âŒ',
        info: 'â„¹ï¸'
      };
      
      toast.innerHTML = `${icons[type] || 'â„¹ï¸'} ${message}`;
      container.appendChild(toast);

      setTimeout(() => {
        toast.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      connect();
    });

    // Handle visibility change
    document.addEventListener('visibilitychange', () => {
      // Reconnect if page becomes visible and socket is disconnected
      if (!document.hidden && socket && !socket.connected) {
        reconnect();
      }
    });
  </script>
</body>
</html>
