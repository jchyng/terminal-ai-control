<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Terminal AI Control</title>
  
  <!-- xterm.js - stable version -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css">
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.min.js"></script>
  
  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>

  <!-- Styles -->
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading">
    <div class="spinner"></div>
    <div class="loading-text">í„°ë¯¸ë„ ì—°ê²° ì¤‘...</div>
  </div>

  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">
        <span class="logo-icon">ğŸ–¥ï¸</span>
        <span>Terminal AI Control</span>
      </div>
      <div class="status-badge">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-text">ì—°ê²° ì¤‘...</span>
        <button class="btn-reconnect" id="reconnect-btn" onclick="reconnect()" title="ì¬ì—°ê²°" style="display: none;">
          ğŸ”„
        </button>
      </div>
    </div>
    <div class="header-actions">
      <div class="toggle-container">
        <label class="toggle-label">
          ğŸ”” <span id="notification-text">ì•Œë¦¼</span>
        </label>
        <label class="toggle-switch">
          <input type="checkbox" id="notification-toggle" onchange="toggleNotification()">
          <span class="toggle-slider"></span>
        </label>
      </div>
    </div>
  </header>

  <!-- Terminal -->
  <div class="terminal-wrapper">
    <div class="terminal-header">
      <div class="terminal-tabs" id="terminal-tabs">
        <!-- Tabs will be dynamically added here -->
      </div>
      <div class="terminal-controls">
        <div class="terminal-control control-close" onclick="window.close()"></div>
        <div class="terminal-control control-minimize"></div>
        <div class="terminal-control control-maximize" onclick="toggleFullscreen()"></div>
      </div>
    </div>
    <div id="terminal-container"></div>
  </div>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-left">
      <div class="shortcut">
        <span class="key">Ctrl</span>+<span class="key">L</span> ì§€ìš°ê¸°
      </div>
      <div class="shortcut">
        <span class="key">Ctrl</span>+<span class="key">C</span> ì¤‘ë‹¨
      </div>
    </div>
    <div class="footer-right">
      Your server. Your network. Your AI.
    </div>
  </footer>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    let socket;
    let terminals = new Map(); // Map of terminalId -> { terminal, fitAddon }
    let activeTerminalId = null;
    let notificationEnabled = false;
    let tabCounter = 0;

    // Create a new terminal instance
    function createTerminalInstance() {
      const terminal = new Terminal({
        cursorBlink: true,
        cursorStyle: 'bar',
        fontSize: 15,
        lineHeight: 1.4,
        fontFamily: '"JetBrains Mono", "Fira Code", "SF Mono", Menlo, Monaco, "Courier New", monospace',
        theme: {
          background: '#252936',
          foreground: '#f0f2f5',
          cursor: '#6c8eef',
          cursorAccent: '#252936',
          selection: 'rgba(108, 142, 239, 0.4)',
          black: '#3d4153',
          red: '#f87171',
          green: '#4ade80',
          yellow: '#fbbf24',
          blue: '#6c8eef',
          magenta: '#c084fc',
          cyan: '#22d3ee',
          white: '#cbd5e1',
          brightBlack: '#64748b',
          brightRed: '#fca5a5',
          brightGreen: '#86efac',
          brightYellow: '#fcd34d',
          brightBlue: '#93b4ff',
          brightMagenta: '#d8b4fe',
          brightCyan: '#67e8f9',
          brightWhite: '#f1f5f9'
        },
        allowTransparency: false,
        scrollback: 10000,
        tabStopWidth: 4
      });

      const fitAddon = new FitAddon.FitAddon();
      const webLinksAddon = new WebLinksAddon.WebLinksAddon();

      terminal.loadAddon(fitAddon);
      terminal.loadAddon(webLinksAddon);

      return { terminal, fitAddon };
    }

    // Add a new terminal tab
    function addTerminalTab() {
      if (!socket?.connected) {
        showToast('ì„œë²„ì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'error');
        return;
      }

      // Request server to create a new terminal
      socket.emit('terminal:create', {
        cols: 80,
        rows: 24
      });
    }

    // Switch to a specific terminal
    function switchTerminal(terminalId) {
      if (activeTerminalId === terminalId) return;

      // Hide current terminal
      if (activeTerminalId) {
        const current = terminals.get(activeTerminalId);
        if (current?.terminal) {
          current.terminal.element.style.display = 'none';
        }
      }

      // Show selected terminal
      const selected = terminals.get(terminalId);
      if (selected?.terminal) {
        selected.terminal.element.style.display = 'block';
        selected.terminal.focus();
        selected.fitAddon.fit();
        activeTerminalId = terminalId;

        // Update tab UI
        updateTabUI();
      }
    }

    // Close a terminal tab
    function closeTerminalTab(terminalId, event) {
      if (event) {
        event.stopPropagation();
      }

      const termData = terminals.get(terminalId);
      if (!termData) return;

      // Don't close if it's the last terminal
      if (terminals.size === 1) {
        showToast('ë§ˆì§€ë§‰ í„°ë¯¸ë„ì€ ë‹«ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
        return;
      }

      // Close on server
      socket.emit('terminal:close', { terminalId });

      // Remove from DOM
      if (termData.terminal?.element) {
        termData.terminal.dispose();
      }

      // Remove from map
      terminals.delete(terminalId);

      // Remove tab from UI
      const tabElement = document.querySelector(`[data-terminal-id="${terminalId}"]`);
      if (tabElement) {
        tabElement.remove();
      }

      // If this was the active terminal, switch to another
      if (activeTerminalId === terminalId) {
        const firstTerminalId = terminals.keys().next().value;
        if (firstTerminalId) {
          switchTerminal(firstTerminalId);
        }
      }
    }

    // Update tab UI to reflect active state
    function updateTabUI() {
      document.querySelectorAll('.terminal-tab').forEach(tab => {
        const terminalId = tab.getAttribute('data-terminal-id');
        if (terminalId === activeTerminalId) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });
    }

    // Render tabs
    function renderTabs() {
      const tabsContainer = document.getElementById('terminal-tabs');
      tabsContainer.innerHTML = '';

      terminals.forEach((termData, terminalId) => {
        const tab = document.createElement('div');
        tab.className = 'terminal-tab';
        tab.setAttribute('data-terminal-id', terminalId);
        tab.onclick = () => switchTerminal(terminalId);

        const label = document.createElement('span');
        label.textContent = `Terminal ${termData.tabNumber}`;
        tab.appendChild(label);

        const closeBtn = document.createElement('span');
        closeBtn.className = 'tab-close';
        closeBtn.innerHTML = 'Ã—';
        closeBtn.onclick = (e) => closeTerminalTab(terminalId, e);
        tab.appendChild(closeBtn);

        tabsContainer.appendChild(tab);
      });

      // Add new tab button
      const newTabBtn = document.createElement('div');
      newTabBtn.className = 'new-tab-btn';
      newTabBtn.innerHTML = '+';
      newTabBtn.onclick = addTerminalTab;
      tabsContainer.appendChild(newTabBtn);

      updateTabUI();
    }

    // Connect to server
    function connect() {
      socket = io({
        reconnection: true,
        reconnectionAttempts: 10,
        reconnectionDelay: 1000
      });

      socket.on('connect', () => {
        console.log('Connected to server');
        updateStatus(true);

        // Create first terminal
        addTerminalTab();
      });

      socket.on('terminal:ready', (data) => {
        console.log('Terminal ready:', data);
        const { terminalId, pid } = data;

        // Create terminal instance
        const { terminal, fitAddon } = createTerminalInstance();

        // Open terminal in container
        terminal.open(document.getElementById('terminal-container'));
        fitAddon.fit();

        // Handle terminal input
        terminal.onData((inputData) => {
          if (socket?.connected) {
            socket.emit('terminal:input', {
              terminalId,
              data: inputData
            });
          }
        });

        // Store terminal
        terminals.set(terminalId, {
          terminal,
          fitAddon,
          tabNumber: ++tabCounter
        });

        // Hide loading on first terminal
        if (terminals.size === 1) {
          document.getElementById('loading').classList.add('hidden');
        }

        // Render tabs and switch to new terminal
        renderTabs();
        switchTerminal(terminalId);

        showToast(`í„°ë¯¸ë„ ${tabCounter} ì—°ê²°ë¨`, 'success');
      });

      socket.on('terminal:data', ({ terminalId, data }) => {
        const termData = terminals.get(terminalId);
        if (termData?.terminal) {
          termData.terminal.write(data);
        }
      });

      socket.on('terminal:exit', ({ terminalId, exitCode }) => {
        const termData = terminals.get(terminalId);
        if (termData?.terminal) {
          termData.terminal.writeln(`\r\n\x1b[33m[í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ: ${exitCode}]\x1b[0m`);
        }
        showToast(`í„°ë¯¸ë„ ${termData?.tabNumber} ì„¸ì…˜ ì¢…ë£Œë¨`, 'info');
      });

      socket.on('terminal:error', (error) => {
        showToast(error, 'error');
      });

      socket.on('disconnect', () => {
        updateStatus(false);
        showToast('ì—°ê²° ëŠê¹€', 'error');
      });

      socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
        updateStatus(false);
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (activeTerminalId) {
          const termData = terminals.get(activeTerminalId);
          if (termData && socket?.connected) {
            termData.fitAddon.fit();
            socket.emit('terminal:resize', {
              terminalId: activeTerminalId,
              cols: termData.terminal.cols,
              rows: termData.terminal.rows
            });
          }
        }
      });
    }

    // Update connection status
    function updateStatus(connected) {
      const dot = document.getElementById('status-dot');
      const text = document.getElementById('status-text');
      const reconnectBtn = document.getElementById('reconnect-btn');

      if (connected) {
        dot.classList.add('connected');
        text.textContent = 'ì—°ê²°ë¨';
        reconnectBtn.style.display = 'none';
      } else {
        dot.classList.remove('connected');
        text.textContent = 'ì—°ê²° ëŠê¹€';
        reconnectBtn.style.display = 'flex';
      }
    }

    // Reconnect
    function reconnect() {
      document.getElementById('loading').classList.remove('hidden');

      // Clear all terminals
      terminals.forEach((termData) => {
        if (termData.terminal) {
          termData.terminal.dispose();
        }
      });
      terminals.clear();
      activeTerminalId = null;
      tabCounter = 0;

      if (socket) {
        socket.disconnect();
      }

      connect();
    }

    // Toggle notification
    function toggleNotification() {
      const toggle = document.getElementById('notification-toggle');

      if (!activeTerminalId) {
        showToast('í™œì„± í„°ë¯¸ë„ì´ ì—†ìŠµë‹ˆë‹¤', 'error');
        toggle.checked = false;
        return;
      }

      notificationEnabled = toggle.checked;

      if (notificationEnabled) {
        if (socket?.connected) {
          socket.emit('terminal:notify-on-complete', { terminalId: activeTerminalId });
          showToast('ì‘ì—… ì™„ë£Œ ì‹œ Discordë¡œ ì•Œë¦¼ì„ ë³´ë‚´ë“œë¦´ê²Œìš”', 'info');
        }
      } else {
        showToast('ì•Œë¦¼ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
      }
    }

    // Toggle fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    // Show toast notification
    function showToast(message, type = 'info') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const icons = {
        success: 'âœ…',
        error: 'âŒ',
        info: 'â„¹ï¸'
      };
      
      toast.innerHTML = `${icons[type] || 'â„¹ï¸'} ${message}`;
      container.appendChild(toast);

      setTimeout(() => {
        toast.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      connect();
    });

    // Handle visibility change (for mobile)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && socket && !socket.connected) {
        reconnect();
      }
    });
  </script>
</body>
</html>
